{"version":3,"sources":["webpack://parseXml/webpack/universalModuleDefinition","webpack://parseXml/./src/index.js","webpack://parseXml/./src/lib/Parser.js","webpack://parseXml/./src/lib/StringScanner.js","webpack://parseXml/./src/lib/XmlCdata.js","webpack://parseXml/./src/lib/XmlComment.js","webpack://parseXml/./src/lib/XmlDocument.js","webpack://parseXml/./src/lib/XmlElement.js","webpack://parseXml/./src/lib/XmlNode.js","webpack://parseXml/./src/lib/XmlProcessingInstruction.js","webpack://parseXml/./src/lib/XmlText.js","webpack://parseXml/./src/lib/syntax.js","webpack://parseXml/webpack/bootstrap","webpack://parseXml/webpack/startup"],"names":["root","factory","exports","module","define","amd","self","this","Parser","XmlCdata","XmlComment","XmlDocument","XmlElement","XmlNode","XmlProcessingInstruction","XmlText","parseXml","xml","options","document","StringScanner","syntax","currentNode","scanner","slice","replace","normalizeXmlString","consumeProlog","consumeElement","error","consumeMisc","isEnd","node","parent","children","push","text","length","prevNode","addNode","chars","quote","peek","advance","isClosed","value","regex","matchLoop","consumeMatch","validateChars","consumeReference","consumeStringFast","consumeUntilString","preserveCdata","addText","charData","consumeUntilMatch","content","preserveComments","trim","ref","consumeWhitespace","mark","charIndex","name","consumeName","reset","attributes","Object","create","attrName","attrValue","consumeEqual","consumeAttributeValue","sortAttributes","attrNames","keys","sort","sortedAttributes","i","isEmpty","Boolean","element","consumeCharData","consumeContentReference","consumeCdataSection","consumeProcessingInstruction","consumeComment","endTagName","endTagMark","isNameStartChar","consumeMatchFn","isNameChar","toLowerCase","consumeXmlDeclaration","consumeDoctypeDeclaration","parsedValue","isReferenceChar","consume","codePoint","parseInt","isNaN","String","fromCodePoint","isXmlChar","predefinedEntities","undefined","ignoreUndefinedEntities","resolveUndefinedEntity","wrappedRef","resolvedValue","type","TypeError","isWhitespace","version","consumeSystemLiteral","test","standalone","message","string","column","excerpt","line","char","eol","indexOf","excerptStart","err","Error","repeat","assign","pos","isNotXmlChar","emptyString","charCount","charsToBytes","Array","multiByteMode","byteIndex","count","Math","min","sticky","lastIndex","result","exec","match","_charLength","fn","startIndex","stringToConsume","charLengthToMatch","global","index","searchString","matchByteIndex","max","TYPE_CDATA","super","TYPE_COMMENT","prototype","toJSON","call","find","child","map","join","TYPE_DOCUMENT","TYPE_ELEMENT","preserveWhitespace","json","isRootNode","TYPE_PROCESSING_INSTRUCTION","TYPE_TEXT","freeze","amp","apos","gt","lt","quot","cp","getCodePoint","codePointAt","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__"],"mappings":"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","file":"parse-xml.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"parse-xml\"] = factory();\n\telse\n\t\troot[\"parseXml\"] = factory();\n})(typeof self === 'undefined' ? this : self, function() {\nreturn ","'use strict';\n\nconst Parser = require('./lib/Parser');\nconst XmlCdata = require('./lib/XmlCdata');\nconst XmlComment = require('./lib/XmlComment');\nconst XmlDocument = require('./lib/XmlDocument');\nconst XmlElement = require('./lib/XmlElement');\nconst XmlNode = require('./lib/XmlNode');\nconst XmlProcessingInstruction = require('./lib/XmlProcessingInstruction');\nconst XmlText = require('./lib/XmlText');\n\n/**\nParses the given XML string and returns an `XmlDocument` instance representing\nthe document tree.\n\n@example\n\n  const parseXml = require('@rgrove/parse-xml');\n  let doc = parseXml('<kittens fuzzy=\"yes\">I like fuzzy kittens.</kittens>');\n\n@param {string} xml\n  XML string to parse.\n\n@param {object} [options]\n  Parsing options.\n\n  @param {boolean} [options.ignoreUndefinedEntities=false]\n    When `true`, an undefined named entity (like \"&bogus;\") will be left in the\n    output as is instead of causing a parse error.\n\n  @param {boolean} [options.preserveCdata=false]\n    When `true`, CDATA sections will be preserved in the document as `XmlCdata`\n    nodes. Otherwise CDATA sections will be represented as `XmlText` nodes,\n    which keeps the node tree simpler and easier to work with.\n\n  @param {boolean} [options.preserveComments=false]\n    When `true`, comments will be preserved in the document as `XmlComment`\n    nodes. Otherwise comments will not be included in the node tree.\n\n  @param {(entity: string) => string?} [options.resolveUndefinedEntity]\n    When an undefined named entity is encountered, this function will be called\n    with the entity as its only argument. It should return a string value with\n    which to replace the entity, or `null` or `undefined` to treat the entity as\n    undefined (which may result in a parse error depending on the value of\n    `ignoreUndefinedEntities`).\n\n  @param {boolean} [options.sortAttributes=false]\n    When `true`, attributes in an element's `attributes` object will be sorted\n    in alphanumeric order by name. Otherwise they'll retain their original order\n    as found in the XML.\n\n@returns {XmlDocument}\n@public\n*/\nfunction parseXml(xml, options) {\n  return (new Parser(xml, options)).document;\n}\n\nparseXml.XmlCdata = XmlCdata;\nparseXml.XmlComment = XmlComment;\nparseXml.XmlDocument = XmlDocument;\nparseXml.XmlElement = XmlElement;\nparseXml.XmlNode = XmlNode;\nparseXml.XmlProcessingInstruction = XmlProcessingInstruction;\nparseXml.XmlText = XmlText;\n\nmodule.exports = parseXml;\n","'use strict';\n\nconst StringScanner = require('./StringScanner');\nconst syntax = require('./syntax');\nconst XmlCdata = require('./XmlCdata');\nconst XmlComment = require('./XmlComment');\nconst XmlDocument = require('./XmlDocument');\nconst XmlElement = require('./XmlElement');\nconst XmlProcessingInstruction = require('./XmlProcessingInstruction');\nconst XmlText = require('./XmlText');\n\nconst emptyString = '';\n\n/**\nParses an XML string into an `XmlDocument`.\n\n@private\n*/\nclass Parser {\n  /**\n  @param {string} xml\n    XML string to parse.\n\n  @param {object} [options]\n    Parsing options.\n\n    @param {boolean} [options.ignoreUndefinedEntities=false]\n    @param {boolean} [options.preserveCdata=false]\n    @param {boolean} [options.preserveComments=false]\n    @param {(entity: string) => string?} [options.resolveUndefinedEntity]\n    @param {boolean} [options.sortAttributes=false]\n  */\n  constructor(xml, options = {}) {\n    /** @type {XmlDocument} */\n    this.document = new XmlDocument();\n\n    /** @type {XmlDocument|XmlElement} */\n    this.currentNode = this.document;\n\n    this.options = options;\n    this.scanner = new StringScanner(normalizeXmlString(xml));\n\n    this.consumeProlog();\n\n    if (!this.consumeElement()) {\n      this.error('Root element is missing or invalid');\n    }\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    if (!this.scanner.isEnd) {\n      this.error('Extra content at the end of the document');\n    }\n  }\n\n  /**\n  Adds the given `XmlNode` as a child of `this.currentNode`.\n\n  @param {XmlNode} node\n  */\n  addNode(node) {\n    node.parent = this.currentNode;\n\n    // @ts-ignore\n    this.currentNode.children.push(node);\n  }\n\n  /**\n  Adds the given _text_ to the document, either by appending it to a preceding\n  `XmlText` node (if possible) or by creating a new `XmlText` node.\n\n  @param {string} text\n  */\n  addText(text) {\n    let { children } = this.currentNode;\n\n    if (children.length > 0) {\n      let prevNode = children[children.length - 1];\n\n      if (prevNode instanceof XmlText) {\n        // The previous node is a text node, so we can append to it and avoid\n        // creating another node.\n        prevNode.text += text;\n        return;\n      }\n    }\n\n    this.addNode(new XmlText(text));\n  }\n\n  /**\n  Consumes an `AttValue` (attribute value) if possible.\n\n  @returns {string|false}\n    Contents of the `AttValue` minus quotes, or `false` if nothing was consumed.\n    An empty string indicates that an `AttValue` was consumed but was empty.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n  */\n  consumeAttributeValue() {\n    let { scanner } = this;\n    let quote = scanner.peek();\n\n    if (quote !== '\"' && quote !== \"'\") {\n      return false;\n    }\n\n    scanner.advance();\n\n    let chars;\n    let isClosed = false;\n    let value = emptyString;\n    let regex = quote === '\"'\n      ? /[^\"&<]+/y\n      : /[^'&<]+/y;\n\n    matchLoop: while (!scanner.isEnd) {\n      chars = scanner.consumeMatch(regex);\n\n      if (chars) {\n        this.validateChars(chars);\n        value += chars.replace(/[\\t\\r\\n]/g, ' ');\n      }\n\n      let nextChar = scanner.peek();\n\n      switch (nextChar) {\n        case quote:\n          isClosed = true;\n          break matchLoop;\n\n        case '&':\n          value += this.consumeReference();\n          continue;\n\n        case '<':\n          this.error('Unescaped `<` is not allowed in an attribute value'); /* istanbul ignore next */\n          break;\n\n        case emptyString:\n          this.error('Unclosed attribute'); /* istanbul ignore next */\n          break;\n\n      }\n    }\n\n    if (!isClosed) {\n      this.error('Unclosed attribute');\n    }\n\n    scanner.advance();\n    return value;\n  }\n\n  /**\n  Consumes a CDATA section if possible.\n\n  @returns {boolean}\n    Whether a CDATA section was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect\n  */\n  consumeCdataSection() {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<![CDATA[')) {\n      return false;\n    }\n\n    let text = scanner.consumeUntilString(']]>');\n    this.validateChars(text);\n\n    if (!scanner.consumeStringFast(']]>')) {\n      this.error('Unclosed CDATA section');\n    }\n\n    if (this.options.preserveCdata) {\n      this.addNode(new XmlCdata(text));\n    } else {\n      this.addText(text);\n    }\n\n    return true;\n  }\n\n  /**\n  Consumes character data if possible.\n\n  @returns {boolean}\n    Whether character data was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\n  */\n  consumeCharData() {\n    let { scanner } = this;\n    let charData = scanner.consumeUntilMatch(/<|&|]]>/g);\n\n    if (!charData) {\n      return false;\n    }\n\n    this.validateChars(charData);\n\n    if (scanner.peek() === ']' && scanner.peek(3) === ']]>') {\n      this.error('Element content may not contain the CDATA section close delimiter `]]>`');\n    }\n\n    this.addText(charData);\n    return true;\n  }\n\n  /**\n  Consumes a comment if possible.\n\n  @returns {boolean}\n    Whether a comment was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment\n  */\n  consumeComment() {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<!--')) {\n      return false;\n    }\n\n    let content = scanner.consumeUntilString('--');\n    this.validateChars(content);\n\n    if (!scanner.consumeStringFast('-->')) {\n      if (scanner.peek(2) === '--') {\n        this.error(\"The string `--` isn't allowed inside a comment\");\n      } else {\n        this.error('Unclosed comment');\n      }\n    }\n\n    if (this.options.preserveComments) {\n      this.addNode(new XmlComment(content.trim()));\n    }\n\n    return true;\n  }\n\n  /**\n  Consumes a reference in a content context if possible.\n\n  This differs from `consumeReference()` in that a consumed reference will be\n  added to the document as a text node instead of returned.\n\n  @returns {boolean}\n    Whether a reference was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc\n  */\n  consumeContentReference() {\n    let ref = this.consumeReference();\n\n    if (ref) {\n      this.addText(ref);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n  Consumes a doctype declaration if possible.\n\n  This is a loose implementation since doctype declarations are currently\n  discarded without further parsing.\n\n  @returns {boolean}\n    Whether a doctype declaration was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd\n  */\n  consumeDoctypeDeclaration() {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<!DOCTYPE')\n        || !this.consumeWhitespace()) {\n\n      return false;\n    }\n\n    scanner.consumeMatch(/[^[>]+/y);\n\n    if (scanner.consumeMatch(/\\[[\\s\\S]+?\\][\\x20\\t\\r\\n]*>/y)) {\n      return true;\n    }\n\n    if (!scanner.consumeStringFast('>')) {\n      this.error('Unclosed doctype declaration');\n    }\n\n    return true;\n  }\n\n  /**\n  Consumes an element if possible.\n\n  @returns {boolean}\n    Whether an element was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element\n  */\n  consumeElement() {\n    let { scanner } = this;\n    let mark = scanner.charIndex;\n\n    if (scanner.peek() !== '<') {\n      return false;\n    }\n\n    scanner.advance();\n    let name = this.consumeName();\n\n    if (!name) {\n      scanner.reset(mark);\n      return false;\n    }\n\n    let attributes = Object.create(null);\n\n    while (this.consumeWhitespace()) {\n      let attrName = this.consumeName();\n\n      if (!attrName) {\n        continue;\n      }\n\n      let attrValue = this.consumeEqual()\n        && this.consumeAttributeValue();\n\n      if (attrValue === false) {\n        this.error('Attribute value expected');\n      }\n\n      if (attrName in attributes) {\n        this.error(`Duplicate attribute: ${attrName}`);\n      }\n\n      if (attrName === 'xml:space'\n          && attrValue !== 'default'\n          && attrValue !== 'preserve') {\n\n        this.error('Value of the `xml:space` attribute must be \"default\" or \"preserve\"');\n      }\n\n      attributes[attrName] = attrValue;\n    }\n\n    if (this.options.sortAttributes) {\n      let attrNames = Object.keys(attributes).sort();\n      let sortedAttributes = Object.create(null);\n\n      for (let i = 0; i < attrNames.length; ++i) {\n        let attrName = attrNames[i];\n        sortedAttributes[attrName] = attributes[attrName];\n      }\n\n      attributes = sortedAttributes;\n    }\n\n    let isEmpty = Boolean(scanner.consumeStringFast('/>'));\n    let element = new XmlElement(name, attributes);\n\n    element.parent = this.currentNode;\n\n    if (!isEmpty) {\n      if (!scanner.consumeStringFast('>')) {\n        this.error(`Unclosed start tag for element \\`${name}\\``);\n      }\n\n      this.currentNode = element;\n      this.consumeCharData();\n\n      while (\n        this.consumeElement()\n          || this.consumeContentReference()\n          || this.consumeCdataSection()\n          || this.consumeProcessingInstruction()\n          || this.consumeComment()\n      ) {\n        this.consumeCharData();\n      }\n\n      let endTagMark = scanner.charIndex;\n      let endTagName;\n\n      if (!scanner.consumeStringFast('</')\n          || !(endTagName = this.consumeName())\n          || endTagName !== name) {\n\n        scanner.reset(endTagMark);\n        this.error(`Missing end tag for element ${name}`);\n      }\n\n      this.consumeWhitespace();\n\n      if (!scanner.consumeStringFast('>')) {\n        this.error(`Unclosed end tag for element ${name}`);\n      }\n\n      this.currentNode = element.parent;\n    }\n\n    this.addNode(element);\n    return true;\n  }\n\n  /**\n  Consumes an `Eq` production if possible.\n\n  @returns {boolean}\n    Whether an `Eq` production was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq\n  */\n  consumeEqual() {\n    this.consumeWhitespace();\n\n    if (this.scanner.consumeStringFast('=')) {\n      this.consumeWhitespace();\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n  Consumes `Misc` content if possible.\n\n  @returns {boolean}\n    Whether anything was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc\n  */\n  consumeMisc() {\n    return this.consumeComment()\n      || this.consumeProcessingInstruction()\n      || this.consumeWhitespace();\n  }\n\n  /**\n  Consumes one or more `Name` characters if possible.\n\n  @returns {string}\n    `Name` characters, or an empty string if none were consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name\n  */\n  consumeName() {\n    return syntax.isNameStartChar(this.scanner.peek())\n      ? this.scanner.consumeMatchFn(syntax.isNameChar)\n      : emptyString;\n  }\n\n  /**\n  Consumes a processing instruction if possible.\n\n  @returns {boolean}\n    Whether a processing instruction was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi\n  */\n  consumeProcessingInstruction() {\n    let { scanner } = this;\n    let mark = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<?')) {\n      return false;\n    }\n\n    let name = this.consumeName();\n\n    if (name) {\n      if (name.toLowerCase() === 'xml') {\n        scanner.reset(mark);\n        this.error(\"XML declaration isn't allowed here\");\n      }\n    } else {\n      this.error('Invalid processing instruction');\n    }\n\n    if (!this.consumeWhitespace()) {\n      if (scanner.consumeStringFast('?>')) {\n        this.addNode(new XmlProcessingInstruction(name));\n        return true;\n      }\n\n      this.error('Whitespace is required after a processing instruction name');\n    }\n\n    let content = scanner.consumeUntilString('?>');\n    this.validateChars(content);\n\n    if (!scanner.consumeStringFast('?>')) {\n      this.error('Unterminated processing instruction');\n    }\n\n    this.addNode(new XmlProcessingInstruction(name, content));\n    return true;\n  }\n\n  /**\n  Consumes a prolog if possible.\n\n  @returns {boolean}\n    Whether a prolog was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd\n  */\n  consumeProlog() {\n    let { scanner } = this;\n    let mark = scanner.charIndex;\n\n    this.consumeXmlDeclaration();\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    if (this.consumeDoctypeDeclaration()) {\n      while (this.consumeMisc()) {} // eslint-disable-line no-empty\n    }\n\n    return mark < scanner.charIndex;\n  }\n\n  /**\n  Consumes a reference if possible.\n\n  This differs from `consumeContentReference()` in that a consumed reference\n  will be returned rather than added to the document.\n\n  @returns {string|false}\n    Parsed reference value, or `false` if nothing was consumed (to distinguish\n    from a reference that resolves to an empty string).\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference\n  */\n  consumeReference() {\n    let { scanner } = this;\n\n    if (scanner.peek() !== '&') {\n      return false;\n    }\n\n    scanner.advance();\n\n    let ref = scanner.consumeMatchFn(syntax.isReferenceChar);\n\n    if (scanner.consume() !== ';') {\n      this.error('Unterminated reference (a reference must end with `;`)');\n    }\n\n    let parsedValue;\n\n    if (ref[0] === '#') {\n      // This is a character reference.\n      let codePoint = ref[1] === 'x'\n        ? parseInt(ref.slice(2), 16) // Hex codepoint.\n        : parseInt(ref.slice(1), 10); // Decimal codepoint.\n\n      if (isNaN(codePoint)) {\n        this.error('Invalid character reference');\n      }\n\n      parsedValue = String.fromCodePoint(codePoint);\n\n      if (!syntax.isXmlChar(parsedValue)) {\n        this.error('Character reference resolves to an invalid character');\n      }\n    } else {\n      // This is an entity reference.\n      parsedValue = syntax.predefinedEntities[ref];\n\n      if (parsedValue === undefined) {\n        let {\n          ignoreUndefinedEntities,\n          resolveUndefinedEntity\n        } = this.options;\n\n        let wrappedRef = `&${ref};`; // for backcompat with <= 2.x\n\n        if (resolveUndefinedEntity) {\n          let resolvedValue = resolveUndefinedEntity(wrappedRef);\n\n          if (resolvedValue !== null && resolvedValue !== undefined) {\n            let type = typeof resolvedValue;\n\n            if (type !== 'string') {\n              throw new TypeError(`\\`resolveUndefinedEntity()\\` must return a string, \\`null\\`, or \\`undefined\\`, but returned a value of type ${type}`);\n            }\n\n            return resolvedValue;\n          }\n        }\n\n        if (ignoreUndefinedEntities) {\n          return wrappedRef;\n        }\n\n        scanner.reset(-wrappedRef.length);\n        this.error(`Named entity isn't defined: ${wrappedRef}`);\n      }\n    }\n\n    return parsedValue;\n  }\n\n  /**\n  Consumes a `SystemLiteral` if possible.\n\n  A `SystemLiteral` is similar to an attribute value, but allows the characters\n  `<` and `&` and doesn't replace references.\n\n  @returns {string|false}\n    Value of the `SystemLiteral` minus quotes, or `false` if nothing was\n    consumed. An empty string indicates that a `SystemLiteral` was consumed but\n    was empty.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral\n  */\n  consumeSystemLiteral() {\n    let { scanner } = this;\n    let quote = scanner.consumeStringFast('\"') || scanner.consumeStringFast(\"'\");\n\n    if (!quote) {\n      return false;\n    }\n\n    let value = scanner.consumeUntilString(quote);\n    this.validateChars(value);\n\n    if (!scanner.consumeStringFast(quote)) {\n      this.error('Missing end quote');\n    }\n\n    return value;\n  }\n\n  /**\n  Consumes one or more whitespace characters if possible.\n\n  @returns {boolean}\n    Whether any whitespace characters were consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\n  */\n  consumeWhitespace() {\n    return Boolean(this.scanner.consumeMatchFn(syntax.isWhitespace));\n  }\n\n  /**\n  Consumes an XML declaration if possible.\n\n  @returns {boolean}\n    Whether an XML declaration was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl\n  */\n  consumeXmlDeclaration() {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<?xml')) {\n      return false;\n    }\n\n    if (!this.consumeWhitespace()) {\n      this.error('Invalid XML declaration');\n    }\n\n    let version = Boolean(scanner.consumeStringFast('version'))\n      && this.consumeEqual()\n      && this.consumeSystemLiteral();\n\n    if (version === false) {\n      this.error('XML version is missing or invalid');\n    } else if (!/^1\\.[0-9]+$/.test(version)) {\n      this.error('Invalid character in version number');\n    }\n\n    if (this.consumeWhitespace()) {\n      let encoding = Boolean(scanner.consumeStringFast('encoding'))\n        && this.consumeEqual()\n        && this.consumeSystemLiteral();\n\n      if (encoding) {\n        this.consumeWhitespace();\n      }\n\n      let standalone = Boolean(scanner.consumeStringFast('standalone'))\n        && this.consumeEqual()\n        && this.consumeSystemLiteral();\n\n      if (standalone) {\n        if (standalone !== 'yes' && standalone !== 'no') {\n          this.error('Only \"yes\" and \"no\" are permitted as values of `standalone`');\n        }\n\n        this.consumeWhitespace();\n      }\n    }\n\n    if (!scanner.consumeStringFast('?>')) {\n      this.error('Invalid or unclosed XML declaration');\n    }\n\n    return true;\n  }\n\n  /**\n  Throws an error at the current scanner position.\n\n  @param {string} message\n  */\n  error(message) {\n    let { charIndex, string: xml } = this.scanner;\n    let column = 1;\n    let excerpt = '';\n    let line = 1;\n\n    // Find the line and column where the error occurred.\n    for (let i = 0; i < charIndex; ++i) {\n      let char = xml[i];\n\n      if (char === '\\n') {\n        column = 1;\n        excerpt = '';\n        line += 1;\n      } else {\n        column += 1;\n        excerpt += char;\n      }\n    }\n\n    let eol = xml.indexOf('\\n', charIndex);\n\n    excerpt += eol === -1\n      ? xml.slice(charIndex)\n      : xml.slice(charIndex, eol);\n\n    let excerptStart = 0;\n\n    // Keep the excerpt below 50 chars, but always keep the error position in\n    // view.\n    if (excerpt.length > 50) {\n      if (column < 40) {\n        excerpt = excerpt.slice(0, 50);\n      } else {\n        excerptStart = column - 20;\n        excerpt = excerpt.slice(excerptStart, column + 30);\n      }\n    }\n\n    let err = new Error(\n      `${message} (line ${line}, column ${column})\\n`\n        + `  ${excerpt}\\n`\n        + ' '.repeat(column - excerptStart + 1) + '^\\n'\n    );\n\n    Object.assign(err, {\n      column,\n      excerpt,\n      line,\n      pos: charIndex\n    });\n\n    throw err;\n  }\n\n  /**\n  Throws an invalid character error if any character in the given _string_ isn't\n  a valid XML character.\n\n  @param {string} string\n  */\n  validateChars(string) {\n    let charIndex = 0;\n\n    for (let char of string) {\n      if (syntax.isNotXmlChar(char)) {\n        this.scanner.reset(-([ ...string ].length - charIndex));\n        this.error('Invalid character');\n      }\n\n      charIndex += 1;\n    }\n  }\n}\n\nmodule.exports = Parser;\n\n// -- Private Functions --------------------------------------------------------\n\n/**\nNormalizes the given XML string by stripping a byte order mark (if present) and\nreplacing CRLF sequences and lone CR characters with LF characters.\n\n@param {string} xml\n@returns {string}\n*/\nfunction normalizeXmlString(xml) {\n  if (xml[0] === '\\uFEFF') {\n    xml = xml.slice(1);\n  }\n\n  return xml.replace(/\\r\\n?/g, '\\n');\n}\n\n/** @typedef {import('./XmlNode')} XmlNode */\n","'use strict';\n\nconst emptyString = '';\n\n/**\n@private\n*/\nclass StringScanner {\n  /**\n  @param {string} string\n  */\n  constructor(string) {\n    /** @type {string[]} */\n    this.chars = [ ...string ];\n\n    /** @type {number} */\n    this.charCount = this.chars.length;\n\n    /** @type {number} */\n    this.charIndex = 0;\n\n    /** @type {number[]} */\n    this.charsToBytes = new Array(this.charCount);\n\n    /** @type {boolean} */\n    this.multiByteMode = false;\n\n    /** @type {string} */\n    this.string = string;\n\n    let { chars, charCount, charsToBytes } = this;\n\n    if (charCount === string.length) {\n      // There are no multibyte characters in the input string, so char indexes\n      // and byte indexes are the same.\n      for (let i = 0; i < charCount; ++i) {\n        charsToBytes[i] = i;\n      }\n    } else {\n      // Create a mapping of character indexes to byte indexes. When the string\n      // contains multibyte characters, a byte index may not necessarily align\n      // with a character index.\n      for (let byteIndex = 0, charIndex = 0; charIndex < charCount; ++charIndex) {\n        charsToBytes[charIndex] = byteIndex;\n        byteIndex += chars[charIndex].length;\n      }\n\n      this.multiByteMode = true;\n    }\n  }\n\n  /**\n  Whether the current character index is at the end of the input string.\n\n  @type {boolean}\n  */\n  get isEnd() {\n    return this.charIndex >= this.charCount;\n  }\n\n  // -- Protected Methods ------------------------------------------------------\n\n  /**\n  Returns the number of characters in the given _string_, which may differ from\n  the byte length if the string contains multibyte characters.\n\n  @param {string} string\n  @returns {number}\n  */\n  _charLength(string) {\n    let { length } = string;\n\n    if (length < 2 || !this.multiByteMode) {\n      return length;\n    }\n\n    // We could get the char length with `[ ...string ].length`, but that's\n    // actually slower than this approach, which replaces surrogate pairs with\n    // single-byte characters.\n    return string.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '_').length;\n  }\n\n  // -- Public Methods ---------------------------------------------------------\n\n  /**\n  Advances the scanner by the given number of characters, stopping if the end of\n  the string is reached.\n\n  @param {number} [count]\n  */\n  advance(count = 1) {\n    this.charIndex = Math.min(this.charCount, this.charIndex + count);\n  }\n\n  /**\n  Consumes and returns the given number of characters if possible, advancing the\n  scanner and stopping if the end of the string is reached.\n\n  If no characters could be consumed, an empty string will be returned.\n\n  @param {number} [count]\n  @returns {string}\n  */\n  consume(count = 1) {\n    let chars = this.peek(count);\n    this.advance(count);\n    return chars;\n  }\n\n  /**\n  Consumes a match for the given sticky regex, advances the scanner, updates the\n  `lastIndex` property of the regex, and returns the matching string.\n\n  The regex must have a sticky flag (\"y\") so that its `lastIndex` prop can be\n  used to anchor the match at the current scanner position.\n\n  Returns the consumed string, or an empty string if nothing was consumed.\n\n  @param {RegExp} regex\n  @returns {string}\n  */\n  consumeMatch(regex) {\n    if (!regex.sticky) {\n      throw new Error('`regex` must have a sticky flag (\"y\")');\n    }\n\n    regex.lastIndex = this.charsToBytes[this.charIndex];\n\n    let result = regex.exec(this.string);\n\n    if (result === null) {\n      return emptyString;\n    }\n\n    let match = result[0];\n    this.advance(this._charLength(match));\n    return match;\n  }\n\n  /**\n  Consumes and returns all characters for which the given function returns a\n  truthy value, stopping on the first falsy return value or if the end of the\n  input is reached.\n\n  @param {(char: string) => boolean} fn\n  @returns {string}\n  */\n  consumeMatchFn(fn) {\n    let startIndex = this.charIndex;\n\n    while (!this.isEnd && fn(this.peek())) {\n      this.advance();\n    }\n\n    return this.charIndex > startIndex\n      ? this.string.slice(this.charsToBytes[startIndex], this.charsToBytes[this.charIndex])\n      : emptyString;\n  }\n\n  /**\n  Consumes the given string if it exists at the current character index, and\n  advances the scanner.\n\n  If the given string doesn't exist at the current character index, an empty\n  string will be returned and the scanner will not be advanced.\n\n  @param {string} stringToConsume\n  @returns {string}\n  */\n  consumeString(stringToConsume) {\n    if (this.consumeStringFast(stringToConsume)) {\n      return stringToConsume;\n    }\n\n    if (!this.multiByteMode) {\n      return emptyString;\n    }\n\n    let { length } = stringToConsume;\n    let charLengthToMatch = this._charLength(stringToConsume);\n\n    if (charLengthToMatch !== length\n        && stringToConsume === this.peek(charLengthToMatch)) {\n\n      this.advance(charLengthToMatch);\n      return stringToConsume;\n    }\n\n    return emptyString;\n  }\n\n  /**\n   * Does the same thing as `consumeString()`, but doesn't support consuming\n   * multibyte characters. This can be much faster if you only need to match\n   * single byte characters.\n   *\n   * @param {string} stringToConsume\n   * @returns {string}\n   */\n  consumeStringFast(stringToConsume) {\n    if (this.peek() === stringToConsume[0]) {\n      let { length } = stringToConsume;\n\n      if (length === 1) {\n        this.advance();\n        return stringToConsume;\n      }\n\n      if (this.peek(length) === stringToConsume) {\n        this.advance(length);\n        return stringToConsume;\n      }\n    }\n\n    return emptyString;\n  }\n\n  /**\n  Consumes characters until the given global regex is matched, advancing the\n  scanner up to (but not beyond) the beginning of the match and updating the\n  `lastIndex` property of the regex.\n\n  The regex must have a global flag (\"g\") so that its `lastIndex` prop can be\n  used to begin the search at the current scanner position.\n\n  Returns the consumed string, or an empty string if nothing was consumed.\n\n  @param {RegExp} regex\n  @returns {string}\n  */\n  consumeUntilMatch(regex) {\n    if (!regex.global) {\n      throw new Error('`regex` must have a global flag (\"g\")');\n    }\n\n    let byteIndex = this.charsToBytes[this.charIndex];\n    regex.lastIndex = byteIndex;\n\n    let match = regex.exec(this.string);\n\n    if (match === null || match.index === byteIndex) {\n      return emptyString;\n    }\n\n    let result = this.string.slice(byteIndex, match.index);\n    this.advance(this._charLength(result));\n    return result;\n  }\n\n  /**\n  Consumes characters until the given string is found, advancing the scanner up\n  to (but not beyond) that point.\n\n  Returns the consumed string, or an empty string if nothing was consumed.\n\n  @param {string} searchString\n  @returns {string}\n  */\n  consumeUntilString(searchString) {\n    let { charIndex, charsToBytes, string } = this;\n    let byteIndex = charsToBytes[charIndex];\n    let matchByteIndex = string.indexOf(searchString, byteIndex);\n\n    if (matchByteIndex <= 0) {\n      return emptyString;\n    }\n\n    let result = string.slice(byteIndex, matchByteIndex);\n    this.advance(this._charLength(result));\n    return result;\n  }\n\n  /**\n  Returns the given number of characters starting at the current character\n  index, without advancing the scanner and without exceeding the end of the\n  input string.\n\n  @param {number} [count]\n  @returns {string}\n  */\n  peek(count = 1) {\n    // Inlining this comparison instead of checking `this.isEnd` improves perf\n    // slightly since `peek()` is called so frequently.\n    if (this.charIndex >= this.charCount) {\n      return emptyString;\n    }\n\n    if (count === 1) {\n      return this.chars[this.charIndex];\n    }\n\n    let { charsToBytes, charIndex } = this;\n    return this.string.slice(charsToBytes[charIndex], charsToBytes[charIndex + count]);\n  }\n\n  /**\n  Resets the scanner position to the given character _index_, or to the start of\n  the input string if no index is given.\n\n  If _index_ is negative, the scanner position will be moved backward by that\n  many characters, stopping if the beginning of the string is reached.\n\n  @param {number} [index]\n  */\n  reset(index = 0) {\n    this.charIndex = index >= 0\n      ? Math.min(this.charCount, index)\n      : Math.max(0, this.charIndex + index);\n  }\n}\n\nmodule.exports = StringScanner;\n","'use strict';\n\nconst XmlNode = require('./XmlNode');\nconst XmlText = require('./XmlText');\n\n/**\nA CDATA section within an XML document.\n\n@public\n*/\nclass XmlCdata extends XmlText {\n  get type() {\n    return XmlNode.TYPE_CDATA;\n  }\n}\n\nmodule.exports = XmlCdata;\n","'use strict';\n\nconst XmlNode = require('./XmlNode');\n\n/**\nA comment within an XML document.\n\n@public\n*/\nclass XmlComment extends XmlNode {\n  /**\n  @param {string} [content]\n  */\n  constructor(content = '') {\n    super();\n\n    /**\n    Content of this comment.\n\n    @type {string}\n    @public\n    */\n    this.content = content;\n  }\n\n  get type() {\n    return XmlNode.TYPE_COMMENT;\n  }\n\n  toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      content: this.content\n    });\n  }\n}\n\nmodule.exports = XmlComment;\n","'use strict';\n\nconst XmlElement = require('./XmlElement');\nconst XmlNode = require('./XmlNode');\n\n/**\nRepresents an XML document. All elements within the document are descendants of\nthis node.\n\n@public\n*/\nclass XmlDocument extends XmlNode {\n  /**\n  @param {Array<XmlComment|XmlElement|XmlProcessingInstruction>} [children]\n  */\n  constructor(children = []) {\n    super();\n\n    /**\n    Child nodes of this document.\n\n    @type {Array<XmlComment|XmlElement|XmlProcessingInstruction>}\n    @public\n    */\n    this.children = children;\n  }\n\n  get document() {\n    return this;\n  }\n\n  /**\n  Root element of this document, or `null` if this document is empty.\n\n  @type {XmlElement?}\n  @public\n  */\n  get root() {\n    // @ts-ignore\n    return this.children.find((child) => child instanceof XmlElement) || null;\n  }\n\n  /**\n  Text content of this document and all its descendants.\n\n  @type {string}\n  @public\n  */\n  get text() {\n    return this.children\n      .map(child => 'text' in child ? child.text : '')\n      .join('');\n  }\n\n  get type() {\n    return XmlNode.TYPE_DOCUMENT;\n  }\n\n  toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      children: this.children.map(child => child.toJSON()),\n    });\n  }\n}\n\nmodule.exports = XmlDocument;\n\n/** @typedef {import('./XmlComment')} XmlComment */\n/** @typedef {import('./XmlProcessingInstruction')} XmlProcessingInstruction */\n","'use strict';\n\nconst XmlNode = require('./XmlNode');\n\n/**\nElement in an XML document.\n\n@public\n*/\nclass XmlElement extends XmlNode {\n  /**\n  @param {string} name\n  @param {{[attrName: string]: string}} [attributes]\n  @param {Array<XmlCdata|XmlComment|XmlElement|XmlProcessingInstruction|XmlText>} [children]\n  */\n  constructor(name, attributes = Object.create(null), children = []) {\n    super();\n\n    /**\n    Name of this element.\n\n    @type {string}\n    @public\n    */\n    this.name = name;\n\n    /**\n    Attributes on this element.\n\n    @type {{[attrName: string]: string}}\n    @public\n    */\n    this.attributes = attributes;\n\n    /**\n    Child nodes of this element.\n\n    @type {Array<XmlCdata|XmlComment|XmlElement|XmlProcessingInstruction|XmlText>}\n    @public\n    */\n    this.children = children;\n  }\n\n  /**\n  Whether this node is empty (meaning it has no children).\n\n  @type {boolean}\n  @public\n  */\n  get isEmpty() {\n    return this.children.length === 0;\n  }\n\n  /** @type {boolean} */\n  get preserveWhitespace() {\n    /** @type {XmlNode?} */\n    let node = this;\n\n    while (node instanceof XmlElement) {\n      if ('xml:space' in node.attributes) {\n        return node.attributes['xml:space'] === 'preserve';\n      }\n\n      node = node.parent;\n    }\n\n    return false;\n  }\n\n  /**\n  Text content of this element and all its descendants.\n\n  @type {string}\n  @public\n  */\n  get text() {\n    return this.children\n      .map(child => 'text' in child ? child.text : '')\n      .join('');\n  }\n\n  get type() {\n    return XmlNode.TYPE_ELEMENT;\n  }\n\n  /** @returns {{[key: string]: any}} */\n  toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      name: this.name,\n      attributes: this.attributes,\n      children: this.children.map(child => child.toJSON()),\n    });\n  }\n}\n\nmodule.exports = XmlElement;\n\n/** @typedef {import('./XmlCdata')} XmlCdata */\n/** @typedef {import('./XmlComment')} XmlComment */\n/** @typedef {import('./XmlProcessingInstruction')} XmlProcessingInstruction */\n/** @typedef {import('./XmlText')} XmlText */\n","'use strict';\n\n/**\nBase interface for a node in an XML document.\n\n@public\n*/\nclass XmlNode {\n  constructor() {\n    /**\n    Parent node of this node, or `null` if this node has no parent.\n\n    @type {XmlDocument|XmlElement|null}\n    @public\n    */\n    this.parent = null;\n  }\n\n  /**\n  Document that contains this node, or `null` if this node is not associated\n  with a document.\n\n  @type {XmlDocument?}\n  @public\n  */\n  get document() {\n    return this.parent\n      ? this.parent.document\n      : null;\n  }\n\n  /**\n  Whether this node is the root node of the document.\n\n  @returns {boolean}\n  @public\n  */\n  get isRootNode() {\n    return this.parent\n      ? this.parent === this.document\n      : false;\n  }\n\n  /**\n  Whether whitespace should be preserved in the content of this element and\n  its children.\n\n  This is influenced by the value of the special `xml:space` attribute, and\n  will be `true` for any node whose `xml:space` attribute is set to\n  \"preserve\". If a node has no such attribute, it will inherit the value of\n  the nearest ancestor that does (if any).\n\n  @type {boolean}\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-white-space\n  @public\n  */\n  get preserveWhitespace() {\n    return Boolean(this.parent && this.parent.preserveWhitespace);\n  }\n\n  /**\n  Type of this node.\n\n  The value of this property is a string that matches one of the static `TYPE_*`\n  properties on the `XmlNode` class (e.g. `TYPE_ELEMENT`, `TYPE_TEXT`, etc.).\n\n  The `XmlNode` class itself is a base class and doesn't have its own type name.\n\n  @type {string}\n  @public\n  */\n  get type() {\n    return '';\n  }\n\n  /**\n  Returns a JSON-serializable object representing this node, minus properties\n  that could result in circular references.\n\n  @returns {{[key: string]: any}}\n  @public\n  */\n  toJSON() {\n    /** @type {{[key: string]: any}} */\n    let json = {\n      type: this.type\n    };\n\n    if (this.isRootNode) {\n      json.isRootNode = true;\n    }\n\n    if (this.preserveWhitespace) {\n      json.preserveWhitespace = true;\n    }\n\n    return json;\n  }\n}\n\n/**\nType value for an `XmlCdata` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_CDATA = 'cdata';\n\n/**\nType value for an `XmlComment` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_COMMENT = 'comment';\n\n/**\nType value for an `XmlDocument` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_DOCUMENT = 'document';\n\n/**\nType value for an `XmlElement` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_ELEMENT = 'element';\n\n/**\nType value for an `XmlProcessingInstruction` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_PROCESSING_INSTRUCTION = 'pi';\n\n/**\nType value for an `XmlText` node.\n\n@type {string}\n@public\n*/\nXmlNode.TYPE_TEXT = 'text';\n\nmodule.exports = XmlNode;\n\n/** @typedef {import('./XmlDocument')} XmlDocument */\n/** @typedef {import('./XmlElement')} XmlElement */\n","'use strict';\n\nconst XmlNode = require('./XmlNode');\n\n/**\nA processing instruction within an XML document.\n\n@public\n*/\nclass XmlProcessingInstruction extends XmlNode {\n  /**\n  @param {string} name\n  @param {string} [content]\n  */\n  constructor(name, content = '') {\n    super();\n\n    /**\n    Name of this processing instruction. Also sometimes referred to as the\n    processing instruction \"target\".\n\n    @type {string}\n    @public\n    */\n    this.name = name;\n\n    /**\n    Content of this processing instruction.\n\n    @type {string}\n    @public\n    */\n    this.content = content;\n  }\n\n  get type() {\n    return XmlNode.TYPE_PROCESSING_INSTRUCTION;\n  }\n\n  toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      name: this.name,\n      content: this.content\n    });\n  }\n}\n\nmodule.exports = XmlProcessingInstruction;\n","'use strict';\n\nconst XmlNode = require('./XmlNode');\n\n/**\nText content within an XML document.\n\n@public\n*/\nclass XmlText extends XmlNode {\n  /**\n  @param {string} [text]\n  */\n  constructor(text = '') {\n    super();\n\n    /**\n    Text content of this node.\n\n    @type {string}\n    @public\n    */\n    this.text = text;\n  }\n\n  get type() {\n    return XmlNode.TYPE_TEXT;\n  }\n\n  toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      text: this.text\n    });\n  }\n}\n\nmodule.exports = XmlText;\n","'use strict';\n\n// -- Exported Constants -------------------------------------------------------\n\n/**\nMapping of predefined entity names to their replacement values.\n\n@type {Readonly<{[name: string]: string}>}\n@see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent\n*/\nconst predefinedEntities = Object.freeze(Object.assign(Object.create(null), {\n  amp: '&',\n  apos: \"'\",\n  gt: '>',\n  lt: '<',\n  quot: '\"'\n}));\n\nexports.predefinedEntities = predefinedEntities;\n\n// -- Exported Functions -------------------------------------------------------\n\n/**\nReturns `true` if _char_ is an XML `NameChar`, `false` if it isn't.\n\n@param {string} char\n@returns {boolean}\n@see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-NameChar\n*/\nfunction isNameChar(char) {\n  if (isNameStartChar(char)) {\n    return true;\n  }\n\n  let cp = getCodePoint(char);\n\n  return cp === 0x2D // -\n    || cp === 0x2E // .\n    || (cp >= 0x30 && cp <= 0x39) // 0-9\n    || cp === 0xB7\n    || (cp >= 0x300 && cp <= 0x36F)\n    || (cp >= 0x203F && cp <= 0x2040);\n}\n\nexports.isNameChar = isNameChar;\n\n/**\nReturns `true` if _char_ is an XML `NameStartChar`, `false` if it isn't.\n\n@param {string} char\n@returns {boolean}\n@see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-NameStartChar\n*/\nfunction isNameStartChar(char) {\n  let cp = getCodePoint(char);\n\n  return cp === 0x3A // :\n    || cp === 0x5F // _\n    || (cp >= 0x41 && cp <= 0x5A) // A-Z\n    || (cp >= 0x61 && cp <= 0x7A) // a-z\n    || (cp >= 0xC0 && cp <= 0xD6)\n    || (cp >= 0xD8 && cp <= 0xF6)\n    || (cp >= 0xF8 && cp <= 0x2FF)\n    || (cp >= 0x370 && cp <= 0x37D)\n    || (cp >= 0x37F && cp <= 0x1FFF)\n    || (cp >= 0x200C && cp <= 0x200D)\n    || (cp >= 0x2070 && cp <= 0x218F)\n    || (cp >= 0x2C00 && cp <= 0x2FEF)\n    || (cp >= 0x3001 && cp <= 0xD7FF)\n    || (cp >= 0xF900 && cp <= 0xFDCF)\n    || (cp >= 0xFDF0 && cp <= 0xFFFD)\n    || (cp >= 0x10000 && cp <= 0xEFFFF);\n}\n\nexports.isNameStartChar = isNameStartChar;\n\n/**\nReturns `true` if _char_ is not a valid XML `Char`, `false` otherwise.\n\n@param {string} char\n@returns {boolean}\n@see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Char\n*/\nfunction isNotXmlChar(char) {\n  return !isXmlChar(char);\n}\n\nexports.isNotXmlChar = isNotXmlChar;\n\n/**\nReturns `true` if _char_ is a valid reference character (which may appear\nbetween `&` and `;` in a reference), `false` otherwise.\n\n@param {string} char\n@returns {boolean}\n@see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-references\n*/\nfunction isReferenceChar(char) {\n  return char === '#' || isNameChar(char);\n}\n\nexports.isReferenceChar = isReferenceChar;\n\n/**\nReturns `true` if _char_ is an XML whitespace character, `false` otherwise.\n\n@param {string} char\n@returns {boolean}\n@see https://www.w3.org/TR/2008/REC-xml-20081126/#white\n*/\nfunction isWhitespace(char) {\n  let cp = getCodePoint(char);\n\n  return cp === 0x20\n    || cp === 0x9\n    || cp === 0xA\n    || cp === 0xD;\n}\n\nexports.isWhitespace = isWhitespace;\n\n/**\nReturns `true` if _char_ is a valid XML `Char`, `false` otherwise.\n\n@param {string} char\n@returns {boolean}\n@see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Char\n*/\nfunction isXmlChar(char) {\n  let cp = getCodePoint(char);\n\n  return cp === 0x9\n    || cp === 0xA\n    || cp === 0xD\n    || (cp >= 0x20 && cp <= 0xD7FF)\n    || (cp >= 0xE000 && cp <= 0xFFFD)\n    || (cp >= 0x10000 && cp <= 0x10FFFF);\n}\n\nexports.isXmlChar = isXmlChar;\n\n// -- Private Functions --------------------------------------------------------\n\n/**\nReturns the Unicode code point value of the given character, or `-1` if _char_\nis empty.\n\n@param {string} char\n@returns {number}\n*/\nfunction getCodePoint(char) {\n  return char.codePointAt(0) || -1;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(138);\n"],"sourceRoot":""}